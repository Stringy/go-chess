package be

// import (
// 	"math"
// 	"fmt"
// )

// const (
// 	MaxPlayer = BlackMove
// 	Depth = 7
// )

// func AlphaBeta(b *Board) int {
// 	return alpha_beta(b, math.MinInt32, math.MaxInt32, 4)
// }

// func AlphaBetaTree(b *Board, tree *Tree) int {
// 	return alpha_beta_tree(b, tree, math.MinInt32, math.MaxInt32, 4)
// }

// func alpha_beta_tree(board *Board, root *Tree, a, b, depth int) int {
// 	if depth == 0 || len(root.Children) == 0 {
// 		fmt.Println(depth, len(root.Children))
// 		return EvalPositionValue(board)
// 	}

// 	if board.NextMove == MaxPlayer {
// 		for _, tree := range root.Children {
// 			board.MakeMove(&tree.Val)
// 			a = int(math.Max(float64(a), float64(alpha_beta_tree(board, &tree, a, b, depth - 1))))
// 			board.UnmakeMove(&tree.Val)
// 			if b <= a {
// 				break
// 			}
// 		}
// 		return a
// 	} else {
// 		for _, tree := range root.Children {
// 			board.MakeMove(&tree.Val)
// 			b = int(math.Min(float64(b), float64(alpha_beta_tree(board, &tree, a, b, depth - 1))))
// 			board.UnmakeMove(&tree.Val)
// 			if b <= a {
// 				break
// 			}
// 		}
// 		return b
// 	}
// 	return 0
// }

// func alpha_beta(board *Board, a, b, depth int) int {
// 	if depth == 0 {
// 		return EvalPositionValue(board)
// 	}
// 	if board.NextMove == MaxPlayer { //black move
// 		moves := GenerateAllMoves(board)
// 		for _, move := range moves {
// 			board.MakeMove(&move)
// 						a = int(math.Max(float64(a), float64(alpha_beta(board, a, b, depth - 1))))
// 			board.UnmakeMove(&move)
// 			if b <= a {
// 				break
// 			}
// 		}
// 		return a
// 	} else { //white move
// 		moves := GenerateAllMoves(board)
// 		for _, move := range moves {
// 			board.MakeMove(&move)
// 			b = int(math.Min(float64(a), float64(alpha_beta(board, depth - 1, a, b))))
// 			board.UnmakeMove(&move)
// 			if b <= a {
// 				break
// 			}
// 		}
// 		return b
// 	}
// 	return 0
// }